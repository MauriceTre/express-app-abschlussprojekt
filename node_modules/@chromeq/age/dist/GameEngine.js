"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEngine = void 0;
const MemoryDataStore_1 = require("./MemoryDataStore");
const events_1 = require("events");
const utils_1 = require("./utils");
class GameEngine extends events_1.EventEmitter {
    /**
     * **GameEngine** constructor accepts two optional props.
     */
    constructor(props) {
        var _a;
        super();
        /**
         * `GameEngine.AGE_ACHIEVED` is the event type used when a player
         * has earned an achievement. The corresponding EventEmitter event
         * object will contain three properities:
         *
         * 1. `player` -- the player that earned this achievement
         * 2. `achievement` -- the achievement that was earned
         * 3. `engine` -- this GameEngine instance
         */
        this.AGE_ACHIEVED = 'achievement-achieved';
        /**
         * `GameEngine.AGE_EVENT` is the event type used when an event has
         * occurred. The corresponding EventEmitter event object will contain
         * three properities:
         *
         * 1. `player` -- the player to which the event occurred
         * 2. `event` -- the event that occurred
         * 3. `engine` -- this GameEngine instance
         */
        this.AGE_EVENT = 'event-occurred';
        this.achievementRules = [];
        /**
         * **`listen`** An alias for `EventEmitter.on`
         */
        this.listen = this.on;
        /**
         * **`addListener`** An alias for `EventEmitter.on`
         */
        this.addListener = this.on;
        /**
         * **`addEventListener`** An alias for `EventEmitter.on`
         */
        this.addEventListener = this.on;
        /**
         * **`dispatch`** An alias for `GameEngine.addEvent`
         */
        this.dispatch = this.addEvent;
        /**
         * **`dispatchEvent`** An alias for `GameEngine.addEvent`
         */
        this.dispatchEvent = this.addEvent;
        /**
         * **`trigger`** An alias for `GameEngine.addEvent`
         */
        this.trigger = this.addEvent;
        /**
         * **`triggerEvent`** An alias for `GameEngine.addEvent`
         */
        this.triggerEvent = this.addEvent;
        this.datastore = (props === null || props === void 0 ? void 0 : props.datastore) || new MemoryDataStore_1.MemoryDataStore();
        this.achievementRules = (props === null || props === void 0 ? void 0 : props.achievementRules) || this.achievementRules;
        // Players aren't stored in GameEngine so loop to the `addPlayer` method
        (_a = props === null || props === void 0 ? void 0 : props.players) === null || _a === void 0 ? void 0 : _a.forEach((player) => {
            this.addPlayer(player);
        });
        this._on = super.on;
    }
    /**
     * **`addPlayer`** ensures that a player object exists for the given `player`.
     * The `player` MUST have an `id` property.
     * @param player Player
     * @returns A function to remove the Player from the engine
     */
    addPlayer(player) {
        return this.datastore.recordPlayer(player);
    }
    /**
     * **`addEvent`** reports that the given `event` occurred for the given `player`.
     *
     * This method will emit a `GameEngine.AGE_EVENT` message to any registered listeners.
     * @param player Player
     * @param event Event
     */
    addEvent(player, eventName, data) {
        const event = {
            name: eventName,
            data,
        };
        this.datastore.recordEvent(player, event);
        this.emit(this.AGE_EVENT, player, event, this);
        const gamePlayer = this.getPlayer(player);
        if (gamePlayer) {
            this.achievementRules.forEach((rule) => {
                this.evaluateAchievementRule(gamePlayer, rule);
            });
        }
    }
    /**
     * **`addAchievement`** reports that the given `player` achieved the specified `achievement`.
     *
     * This method will emit a `GameEngine.AGE_ACHIEVED` message to any registered listeners.
     * @param player Player
     * @param achievementName Achievement Name
     */
    addAchievement(player, achievementName) {
        const achievement = {
            name: achievementName,
            achieved: new Date(),
        };
        this.datastore.recordAchievement(player, achievement);
        this.emit(this.AGE_ACHIEVED, player, achievement, this);
    }
    /**
     * **`addAchievementRule`** registers a new achievement rule with the GameEngine.
     * Subsequent invocations of `getPlayerAchievements` will evaluate the given
     * achievement rule.
     *
     * See the `AchievementRule` type for more details.
     * @param rule Achievement Rule
     * @returns A function to remove the Rule from the engine
     */
    addAchievementRule(rule) {
        this.achievementRules.push(rule);
        return () => {
            const index = this.achievementRules.findIndex((r) => r === rule);
            if (index > -1) {
                this.achievementRules.splice(index, 1);
            }
        };
    }
    /**
     * **`getPlayer`** will fetch the player object specified by `player.id`.
     * @param player Player
     * @returns GamePlayer
     */
    getPlayer(player) {
        return this.datastore.getPlayer(player);
    }
    /**
     * **`getPlayerHistory`** returns an array of events experienced by the player with the given `player.id`.
     * By default this method simply invokes `.history` on the value obtained from `getPlayer`.
     * @param player Player
     * @returns Player History
     */
    getPlayerHistory(player) {
        return this.datastore.getPlayerHistory(player);
    }
    /**
     * **`getPlayerAchievements`** returns an array of achievements achieved by the player with the given `player.id`.
     * By default this method simply invokes `.achievements` on the value obtained from `getPlayer`.
     * @param player Player
     * @returns Player Achievements
     */
    getPlayerAchievements(player) {
        return this.datastore.getPlayerAchievements(player);
    }
    /**
     * **`evaluateAchievementRule`** is a private utility method.
     * This method will evaluate the given `rule` for the given `player` by
     * parsing the keys in order to invoke the predicate for each key.
     * @param player Player
     * @param rule Achievement Rule
     */
    evaluateAchievementRule(player, rule) {
        const key = typeof rule.key === 'function' ? rule.key(player, this) : rule.key;
        const keys = Array.isArray(key) ? key : [key];
        keys.forEach((key) => {
            this.evaluateSingleAchievement(player, key, rule);
        });
    }
    /**
     * **`evaluateSingleAchievement`** is a private utility method.
     * This method will evaluate the given `rule` for the given `player`
     * and make the requisite changes to the game state.
     * @param player Player
     * @param key Key
     * @param rule Achievement Rule
     */
    evaluateSingleAchievement(player, key, rule) {
        if (rule.multiplicity > 0) {
            const count = (0, utils_1.countAchievement)(player.achievements, key, rule.multiplicity);
            if (count >= rule.multiplicity) {
                return;
            }
        }
        const achieved = rule.predicate(player, this);
        if (achieved) {
            player.achievements;
            if (!rule.transient) {
                this.addAchievement(player.data, key);
            }
            else {
                throw new Error('TODO: Transient rules not implemented');
            }
        }
    }
    on(type, listener) {
        this._on.call(this, type, listener);
        return this;
    }
}
exports.GameEngine = GameEngine;
